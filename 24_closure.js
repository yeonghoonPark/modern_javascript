"use strict";

/**
 * 24. 클로저(closure)
 *
 * 클로저는 자바스크립트 고유의 개념이 아니다.
 * 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어(Haskell, Lisp, Scala, and etc)에서 사용되는 특성이다.
 * MDN에서는 클로저에 대해 다음과 같이 정의하고 있다.
 *
 * "A closure is the combination of a function and the lexical environment within which that function was declared."
 * "클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다."
 *
 * 클로저는 렉시컬 스코프에 따라 상위 스코프에서 하위 스코프를 참조할 수 없는 문제를 해결함과 동시에 상위 스코프에서 하위 스코프의 식별자를 계속 참조할 수 있는 개념이다.
 * 실행 컨텍스트가 생성될 때 환경 레코드도 생성되지만, 실행 컨텍스트가 종료된다고 하더라도 환경 레코드는 바로 사라지지 않는다는 점을 이용한 것이며,
 * 이는 정보 은닉, 상태의 지속성 유지, 캡슐화, 비동기 처리, 코드 모듈화 등의 장점으로 이어진다.
 *
 *
 * 📚. 일급 객체(`first-class object`)란?
 *  1. 무명으로 생성할 수 있다. 즉, 런-타임에 생성할 수 있다.
 *  2. 변수나 자료구조(객체, 배열)에 저장할 수 있다.
 *  3. 함수의 인자와 반환값으로 사용할 수 있다. 즉 값으로 사용할 수 있다.
 *  위의 조건을 만족하는 객체를 일급 객체라 한다.
 *
 * 📚. 렉시컬 스코프(`lexical scope`)란?
 *  - 함수가 어디서 정의되었냐에 따라 상위 스코프를 참조하는 방식이다.
 *   (반대 개념은 다이나믹 스코프(`dynamic scope`)라 하며 함수가 실행될 때 호출 위치에 따라 상위 스코프를 참조하는 방식이다.)
 *
 */

// 👉 예문
{
  // `inner` 함수는 `outer` 함수의 중첩 함수로 정의되었으며,
  // `outer` 함수는 `inner` 함수의 상위 스코피이다.
  // `inner` 함수는 `outer` 함수의 식별자 `x`를 참조할 수 있지만,
  // 반대로 `outer` 함수는 `inner` 함수 내부에서 선언된 식별자 `y`를 참조할 수 없다.
  // 이는 자바스크립트가 렉시컬 스코프를 따르는 프로그래밍 언어이기 때문에 발생하는 현상이다.

  const outer = () => {
    const x = 10;
    // console.log(y); // ReferenceError: y is not defined

    const inner = () => {
      const y = 10;
      console.log(x); // 10
    };

    inner();
  };

  outer();
}

/**
 * 24-1. 렉시컬 스코프(Lexical scope)
 *
 * 렉시컬 스코프란,
 * 🔑 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정하는 방식을 말한다.
 *
 * 자바스크립트는 렉시컬 스코프를 가진다.
 * 소스코드에 따라 실행 컨텍스트가 생성되면 변수나 함수와 같은 식별자를 관리하기 위한 렉시컬 환경이 생성된다.
 * 렉시컬 환경은 2가지 컴포넌트로 구성된다.
 * 생성된 실행 컨텍스트의 식별자를 관리하기 위한 "환경 레코드"와
 * 상위 스코프의 식별자를 참조하기 위한 "외부 렉시컬 환경 참조"로 구성된다.
 * 여기서 말하는 상위 스코프를 결정하는 방식에 대해 렉시컬 스코프를 따르며, 이 개념을 반영하여 렉시컬 스코프를 정의한다면
 * "외부 렉시컬 환경에 대한 참조"에 저장할 참조값,
 * 🔑 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 위치에 의해 결정된다.
 *
 * 이를 렉시컬 스코프라 한다.
 *
 */

// 👉 예문

// 자바스크립트에서 상위 스코프는 함수를 어디서 정의했느냐에 따라 결정된다.
// `foo` 함수와 `bar` 함수는 전역 소스코드에서 정의되므로, 두 함수의 상위 스코프는 전역이다.
// `foo` 함수 내부에서 `bar` 함수를 호출하였지만, 함수의 호출 위치는 상위 스코프를 결정하는데 아무런 영향도 주지 못한다.
// 즉, 함수의 상위 스코프는 함수를 정의한 위치에 의해 정적으로 결정되고 변하지 않는다.

const x = 1;

function foo() {
  const x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1

/**
 * 24-2. 함수 객체의 내부 슬롯 [[Environment]]
 *
 * 함수는 정의된 위치(환경)와 호출되는 위치(환경)가 다를 수 있다.
 * 렉시컬 스코프가 가능하려면 함수 자신이 호출되는 위치와 상관없이 자신이 정의된 위치,
 * 상위 스코프(함수 정의가 위치하는 스코프가 바로 상위 스코프다)를 기억해야한다.
 * 🔑 함수는 자신이 정의된 위치, 즉 상위 스코프를 기억하기 위해 [[Environment]]에 자신이 정의된 환경을 참조한다.
 * 다시 말해 [[Environment]]에 참조된 값은 "외부 렉시컬 환경 참조"다.
 *
 */

// 👉 예문
{
  const x = 1;

  // `bar` 함수는 [[Environment]] 내부 슬롯에 예문의 {} 스코프의 환경을 참조한다.
  const bar = () => {
    console.log(x);
  };

  const foo = () => {
    const x = 10;

    // `bar` 함수의 상위 스코프는 `bar` 함수가 정의된 곳이다.
    // 따라서 해당 예문에서는 {} 내부를 의미한다.
    bar();
  };

  foo(); // 1
  bar(); // 1
}
