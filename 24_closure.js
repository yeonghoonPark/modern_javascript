"use strict";

/**
 * 24. 클로저(closure)
 *
 * 클로저는 자바스크립트 고유의 개념이 아니다.
 * 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어(Haskell, Lisp, Scala, and etc)에서 사용되는 특성이다.
 * MDN에서는 클로저에 대해 다음과 같이 정의하고 있다.
 *
 * "A closure is the combination of a function and the lexical environment within which that function was declared."
 * "클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다."
 *
 * 클로저는 렉시컬 스코프에 따라 상위 스코프에서 하위 스코프를 참조할 수 없는 문제를 해결함과 동시에 상위 스코프에서 하위 스코프의 식별자를 계속 참조할 수 있는 개념이다.
 * 실행 컨텍스트가 생성될 때 환경 레코드도 생성되지만, 실행 컨텍스트가 종료된다고 하더라도 환경 레코드는 바로 사라지지 않는다는 점을 이용한 것이며,
 * 이는 정보 은닉, 상태의 지속성 유지, 캡슐화, 비동기 처리, 코드 모듈화 등의 장점으로 이어진다.
 *
 *
 * 📚. 일급 객체(`first-class object`)란?
 *  1. 무명으로 생성할 수 있다. 즉, 런-타임에 생성할 수 있다.
 *  2. 변수나 자료구조(객체, 배열)에 저장할 수 있다.
 *  3. 함수의 인자와 반환값으로 사용할 수 있다. 즉 값으로 사용할 수 있다.
 * 위의 조건을 만족하는 객체를 일급 객체라 한다.
 *
 * 📚. 렉시컬 스코프(`lexical scope`)란?
 *  - 함수가 어디서 정의되었냐에 따라 상위 스코프를 참조하는 방식이다.
 *   (반대 개념은 다이나믹 스코프(`dynamic scope`)라 하며 함수가 실행될 때 호출 위치에 따라 상위 스코프를 참조하는 방식이다.)
 *
 */

// 👉 예문
{
  // `inner` 함수는 `outer` 함수의 중첩 함수로 정의되었으며,
  // `outer` 함수는 `inner` 함수의 상위 스코피이다.
  // `inner` 함수는 `outer` 함수의 식별자 `x`를 참조할 수 있지만,
  // 반대로 `outer` 함수는 `inner` 함수 내부에서 선언된 식별자 `y`를 참조할 수 없다.
  // 이는 자바스크립트가 렉시컬 스코프를 따르는 프로그래밍 언어이기 때문에 발생하는 현상이다.

  const outer = () => {
    const x = 10;
    console.log(y); // ReferenceError: y is not defined

    const inner = () => {
      const y = 10;
      console.log(x); // 10
    };

    inner();
  };

  outer();
}
