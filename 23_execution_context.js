/**
 * 23-1. 소스코드의 타입
 *
 * 실행 컨텍스트(execution context)는 자바스크립트의 동작 원리를 담고 있는 핵심 개념이다.
 * 실행 컨텍스트를 바르게 이해하면 스코프, 식별자, 호이스팅, 클로저, 태스크 큐, 이벤트 핸들러 등의 동작을 이해할 수 있다.
 * ECMAScript 사양은 소스코드를 4가지 타입으로 구분한다.
 * 아래의 4가지 타입의 소스코드는 실행 컨텍스트를 생성한다.
 *
 * 1. 전역 코드 (global code)
 * - 전역에 존재하는 소스 코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다.
 *
 * 2. 함수 코드 (function code)
 * - 함수 내부에 존재하는 코드를 말한다. 함수 내부에 중첩 함수, 클래스 등의 내부 코드는 포함되지 않는다.
 *
 * 3. eval 코드 (eval code)
 * - 전역 객체의 메서드인 `eval` 메서드에 인자로 전달되어 실행되는 코드를 말한다.
 *
 * 4. 모듈 코드 (module code)
 * - 모듈 내부에 존재하는 소스 코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.
 *
 * 위의 4가지 타입의 소스 코드로 구분하는 이유는 타입에 따라 실행 컨텍트스를 생성하는 과정과 관리 내용이 다르기 때문이다.
 *
 * 즉,
 * 🔑 실행 컨텍스트는 식별자의 유효 범위를 설정하는 스코프 체인을 생성하고 관리하는 역할을 하며,
 * 소스코드의 타입에 따라 실행 컨텍스트를 생성하고 관리하는 방식이 다르다는 점을 유의해야 한다.
 *
 */

// 1️⃣ 전역 코드 (global code) / 전역 실행 컨텍스트 (global execution context)
// 전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성한다.
// `var` 키워드로 선언된 전역 변수와 `function` 키워드로 정의된 전역 함수들을 전역 객체의 프로퍼티와 메서드로 참조(바인딩)하기 위해 전역 객체와 연결되어야 한다.
// 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.
// 📚 전역 실행 컨텍스트는 브라우저에서 페이지가 로드될 때 생성된다.

// 2️⃣ 함수 코드 (function code) / 함수 실행 컨텍스트 (function execution context)
// 함수 코드는 지역 변수, 매개변수, argument 객체를 관리하기 위해 지역 스코프를 생성한다.
// 생성한 지역 스코프는 상위 스코프 또는 전역 스코프와 스코프체인의 일원으로 연결해야 한다.
// 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.
// 📚 함수 실행 컨텍스트는 함수로 평가되거나 함수가 호출될 때마다 새로 생성된다.
// 🔑 함수 실행 컨텍스트는 키워드에 따라 다르게 동작한다.
// `function`: 함수 선언이 호이스팅되어 전역 컨텍스트가 생성될 때 이미 함수로 평가되므로, 함수 실행 컨텍스트가 즉시 생성된다.
// `var`: 호이스팅은 발생하지만 변수 선언만 호이스팅되어 함수 표현식이 실제로 할당될 때 함수 실행 컨텍스트가 생성된다.
// `let` / `const`: 호이스팅은 발생하지만 TDZ(Temporal Dead Zone)로 인해 선언 전에 참조할 수 없으며, 정의된 후에 호출 시 함수 실행 컨텍스트가 생성된다.

// 3️⃣ eval 코드 (eval code) / eval 실행 컨텍스트 (eval execution context)
// `eval` 코드는 스트릭트 모드에서는 자신만의 독자적인 스코프를 생성하고, 논-스트릭트 모드라면 외부 스코프(전역 또는 함수)를 공유한다.
// 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스트가 생성된다.
// 📚 eval 실행 컨텍스트는 `eval` 함수가 호출될 때 생성된다.
// ❌ 보안, 성능의 문제로 사용하지 않아야 한다.

// 4️⃣ 모듈 코드 (module code) / 모듈 실행 컨텍스트 (module execution context)
// 모듈 코드는 모듈별로 독립적인 모듈 스코프를 생성한다.
// 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다.
// 📚 모듈 실행 컨텍스트는 `export` 키워드가 사용된 변수, 함수, 클래스 등의 모듈이 `import` 키워드를 통해 모듈을 로드할 때 생성된다.

/**
 * 23-2. 소스코드의 평가와 실행
 *
 * 자바스크립트 엔진은 런타임 이전에 소스코드를 평가하고, 런타임에 소스코드를 실행한다.
 * 소스코드를 2개의 과정, 즉 `소스코드 평가` → `소스코드 실행` 과정으로 나누어 처리한다.
 *
 * 소스코드를 평가(parsing or interpreting)하는 과정에서는
 * 소스코드에 따라 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 프로퍼티 키로 실행 컨텍스트가 관리하는 스코프에 등록한다.
 *
 * 소스코드를 실행(run-time)하는 과정에서는
 * 소스코드를 실행하는 데 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 참조한다.
 * 이때 변숫값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프(lexical scope)에 등록된다.
 *
 */

// 👉 소스코드 예문
// 아래의 소스코드는 `소스코드 평가`와 `소스코드 실행`으로 분리할 수 있다.

// 소스코드 평가(parsing or interpreting): `var` 키워드를 이용하여 선언된 식별자 `x`는 실행 컨텍스트를 통해 스코프에 등록되고 초기화 과정을 거쳐 `undefined`를 참조하게 된다.
var x; // undefined

// 소스 코드 실행(run-time): 식별자 `x`가 선언된 변수인지 확인 후, 식별자 `x`는 10이라는 값을 참조한다. (만약 선언되지 않았다면 암묵적 전역이 발생한다)
x = 10;

/**
 * 23-3. 실행 컨텍스트의 역할
 *
 * 실행 컨텍스트는 식별자(변수, 함수 클래스 등)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현하는 내부 메커니즘이다.
 * 이때 식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리되며 실행 순서는 실행 컨텍스트의 스택 자료구조로 관리된다.
 *
 */

// 👉 소스코드 예문
// 아래의 소스코드는 실행 컨텍스트 단위로 `소스코드 평가`와 `소스코드 실행`으로 분리할 수 있다.

// 전역 변수 선언
const a = 1;
const b = 2;

// 전연 함수 선언
function foo(number) {
  // 지역 변수 선언
  const a = 10;
  const b = 20;

  // 반환
  return number + a + b;
}

foo(100); // 130

a + b; // 3

// 1️⃣. 전역 소스코드 평가
// 소스코드가 평가되는 과정에서는 선언문만 먼저 평가한다.
// 이때 `function` 키워드를 이용하여 선언한 `foo` 함수만 생성된 전역 컨텍스트를 통해 전역 객체의 메서드로 등록된다.
// 만약 `var` 키워드를 이용한 전연 변수가 선언되어 있었다면 해당 식별자는 전역 객체의 프로퍼티로 등록된다.
// 🔑 이때 `let` 또는 `const` 키워드를 이용한 변수 선언문 또한 호이스팅이 발생하고 평가되지만, 초기화는 소스코드를 실행하는 과정에서 이루어지기 때문에 자바스크립트는 초기화하지 않은 변수를 참조할 수 없어 `TDZ`가 일시적으로 발생한다.

// 2️⃣. 전역 소스코드 실행
// 전역 소스코드 평가 과정이 끝났다면 전역 소스코드를 순차적으로 실행한다.
// 이때 전역 변수에 값이 할당되고 함수가 호출된다. (즉, `const` 키워드를 사용한 전역 변수인 `a`와 `b`에 초기화 → 할당이 이루어진다)
// 순차적으로 코드를 실행하는 중 `foo` 함수가 호출되면 순차적으로 실행되던 전역 소스코드 실행은 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.
// 🔑 코드가 일시적으로 중단된다는 의미는 호출 스택에 쌓인 상태라는 의미다.

// 3️⃣. 함수 소스코드 평가
// `foo` 함수 호출에 의해 코드 실행 순서가 변경되어 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 함수 내부의 선언문을 평가한다.
// 이때 매개변수로 전달된 인자와 지역 변수 등을 평가하고 함수 실행 컨텍스트에 등록한다. (이때 `this` 바인딩도 결정된다)
// 🔑 함수 실행 컨텍스트가 호출 스택에 쌓이기 전에 매개변수로 전달된 인자와 지역 변수는 호이스팅이 발생한다.

// 4️⃣. 함수 소스코드 실행
// 함수 소스코드 평가가 끝나면 순차적으로 함수 소스코드를 순차적으로 실행한다.
// 이때 매개변수로 전달된 인자와 지역 변수의 값이 할당되고 연산을 통해 값을 반환한다.
// 모든 소스코드를 실행하여 반환까지 완료하면 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다.
// 🔑 함수 소스코드 실행될 때 콜 스택에 쌓이고 실행이 종료되면 콜 스택에서 해당 함수 실행 컨텍스트가 빠져나온다는 것을 의미한다. 호출 스택은 `LIFO`(Last In First Out)의 구조를 가지며 해당 실행 컨텍스트 스택이 종료되면 전역 소스코드를 실행하는 부분으로 돌아가 순차적으로 코드를 끝까지 실행한다.

// 🔑 실행 컨텍스트는 스코프, 식별자, 코드 실행 순서를 관리한다.
// 1. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)의 스코프를 구분하고 등록하여 지속적으로 관리한다.
// 2. 스코프는 중첩 관계에 의해 스코프 체인을 형성하며 상위 스코프의 식별자를 참조할 수 있다.
// 3. 현재 실행 중인 코드의 실행 순서를 변경할 수 있고 종료되면 다시 돌아갈 수 있다.
// 즉, 실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 역할을 한다.

/**
 * 23-4. 실행 컨텍스트 스택
 *
 * 소스코드에 따라 스코프의 유효 범위, 스코프체인, 실행 순서를 관리하는 실행 컨텍스트는 스택(stack) 자료구조로 관리된다.
 * 이를 실행 컨텍스트 스택이라고 한다.
 * 실행 컨텍스트 스택은 `LIFO`의 구조를 가지며 순서에 따라 추가(push)되고 제거(pop)된다.
 *
 */

// 👉 소스코드 예문
// 전역 변수 선언
const numOne = 1;

// 전역 함수 선언
function qux() {
  // 지역 변수 선언
  const numTwo = 2;

  // 중첩 함수 선언
  function bar() {
    // 지역 변수 선언
    const numThree = 3;

    return numOne + numTwo + numThree;
  }

  return bar();
}

qux(); // 6

// 위 소스코드를 실행 컨텍스트 스택에 자료구조는
// `전역 실행 컨텍스트` → `quz 함수 실행 컨텍스트` → `bar 함수 실행 컨텍스트` 순으로 추가되고.
// `bar 함수 실행 컨텍스트` → `quz 함수 실행 컨텍스트` → `전역 실행 컨텍스트` 순으로 제거된다.

// 위 소스코드의 평가와 실행 단계를 기술하면 다음과 같다.
// 1. 전역 소스코드 평가와 실행
// 평가: 전역 코드를 평가하여 전역 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 추가한다.
// 👉 전역 변수 `numOne`과 전역 함수 `qux`는 전역 실행 컨텍스트에 등록된다.
// 실행: 전역 코드가 순차적으로 실행된다.
// 👉 `const` 키워드로 선언된 `numOn`은 초기화와 재할당 단계를 거쳐 값을 가지고 함수 `qux`가 호출된다.

// 2. qux 함수 소스코드 평가와 실행
// `qux` 함수가 호출되면 전역 실행 컨텍스트는 스택에 쌓인 채 잠시 중단되고 코드의 제어권은 `qux` 함수 내부로 이동하여 평가와 실행 단계를 거친다.
// 평가: 함수 코드를 평가하여 `qux` 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 추가한다.
// 👉 지역 변수인 `numTwo`와 중첩 함수 `bar`는 함수 실행 컨텍스트에 등록된다.
// 실행: 함수 코드가 순차적으로 실행된다.
// 👉 `const` 키워드로 선언된 `numTwo`는 초기화와 재할당 단계를 거쳐 값을 가지고 반환값인 함수 `bar`가 호출된다.

// 3. bar 함수 소스코드 평가와 실행
// `bar` 함수가 호출되면 `bar` 함수 실행 컨텍스트는 스택에 쌓인 채 잠시 중단되고 코드의 제어권은 `bar` 함수 내부로 이동하여 평가와 실행 단계를 거친다.
// 평가: 함수 코드를 평가하여 `bar` 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 추가한다.
// 👉 지역 변수인 `numThree`는 `bar` 함수 실행 컨텍스트에 등록된다.
// 실행: 함수 코드가 순차적으로 실행된다.
// 👉 `const` 키워드로 선언된 `numThree` 는 초기화와 재할당 단계를 거쳐 값을 가지고 연산한 값을 반환하는 것을 끝으로 함수를 종료한다.

// 4. qux 함수 소스코드로 복귀
// `bar` 함수가 종료되면 코드의 제어권은 다시 `foo` 함수로 이동한다.
// 👉 자바스크립트 엔진은 `bar` 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 제거한다.
// `quz` 함수는 `bar` 함수를 반환하는 것을 끝으로 함수를 종료한다.

// 5. 전역 실행 소스코드로 복귀
// `foo` 함수가 종료되면 코드의 제어권은 다시 전역 소스코드로 이동한다.
// 👉 자바스크립트 엔진은 `foo` 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 제거한다.
// 이로써 실행 컨텍스트에는 아무것도 남아있지 않게 된다.

// 🔑 실행 컨텍스트 스택은 코드의 실행 순서를 관리한다.
// 실행 컨텍스트 스택인 `LIFO`의 구조를 가지며 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 실행 중인 코드의 실행 컨텍스트다.
// 이를 실행 중인 실행 컨텍스트(running execution context)라 한다.

/**
 * 23-5. 렉시컬 환경
 *
 * 렉시컬 환경(lexical environment)는
 * 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다.
 * 실행 컨텍스트 스택(호출 스택)이 코드의 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리한다.
 * 렉시컬 환경은 키와 값을 갖는 객체 형태의 스코프(전역, 함수, 블록)를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.
 *
 * 🔑 즉, 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체이다.
 *
 */

// 👉 소스코드 예문
const r = 1;

function rux() {
  const t = 2;
  return r + t;
}

rux(); // 3

// 위 소스코드 예문이 실행되면 전역 렉시컬 환경과 함수 렉시컬 환경에 식별자가 등록된다.
// 1️⃣. 전역 렉시컬 환경에는 const 키워드로 등록된 식별자 `r`과 function 키워드로 등록된 `rux` 함수가 등록된다.
// 2️⃣. 함수 렉시컬 환경에는 const 키워드로 등록된 식별자 `t`가 등록된다.
// 전역 렉시컬 환경과 `rux` 함수 렉시컬 환경은 스코프체인 관계를 맺는다.

// 렉시컬 환경은 2개의 컴포넌트로 구분된다.
// 1️⃣. 환경 레코드(environment record)
// - 스코프에 포함된 식별자를 등록하고 바인딩된 값을 관리하는 저장소다.
// 2️⃣. 외부 렉시컬 환경에 대한 참조(outer lexical environment reference)
// - 렉시컬 환경의 환경 레코드 스코프의 상위 스코프를 가리킨다.
// 상위 스코프란 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경을 말하며, 참조를 통해 스코프체인을 구현한다.

/**
 * 23-6. 실행 컨텍스트의 생성과 식별자 검색 과정
 *
 */

// 👉 소스코드 예문
var xx = 1;
const yy = 2;

function outer(aa) {
  var xx = 3;
  const yy = 4;

  function inner(bb) {
    const zz = 5;

    console.log(aa + bb + xx + yy + zz);
  }

  inner(10);
}

outer(20); // 42

// --------------------------------------------------------------------------------------------------------------
// ✅ 23-6-1. 전역 객체 생성
// 전역 객체는 전역 코드가 평가되기 이전에 생성된다.
// 전역 객체는 빌트인 전역 프로퍼티와 전역 메서드, 그리고 표준 빌트인 객체가 추가되며, 실행 환경에 따라 호스트 객체를 포함한다.
// 전역 객체도 Object.prototype을 상속받는다. 즉, 전역 객체도 프로토타입 체인의 일원이다.
window.__proto__.__proto__.__proto__.__proto__ === Object.prototype;
// --------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------
// ✅ 23-6-2. 전역 코드 평가
// 소스코드가 로드되면 자바스크립트 엔진은 전역 코드를 평가하며, 다음과 같은 순서로 진행된다.
//
// 1️. 전역 실행 컨텍스트 생성 (global execution context)
// 👉 비어 있는 호출 스택에 전역 실행 컨텍스트를 생성하여 푸시한다. 이때 전역 실행 컨텍스트는 코드의 제어권을 가지는 실행 중인 실행 컨텍스트가 된다.
//
// 2️. 전역 렉시컬 환경 생성 (global lexical environment)
// 👉 호출 스택에 최상위에 위치한 현재 실행 중인 실행 컨텍스트인 전역 실행 컨텍스트의 전역 렉시컬 환경을 생성하고 실행 컨텍스트에 바인딩한다.
// 렉시컬 환경은 내부 스코프를 정의하는 "환경 레코드"와 "외부 스코프를 참조하는 외부 렉시컬 환경에 대한 참조"로 구성된다.
//
//  2-1. 전역 환경 레코드 생성 (global environment record)
//  🔑 `let`, `const` 키워드가 존재하지 않는 ES6 이전에는 내부 스코프를 정의하는 곳이 "환경 레코드" 밖에 존재하지 않았다.
//  하지만, ES6에 등장한 `let`, `const` 키워드는 전역 객체에 등록되지 않는 개념적인 블록 내에 존재하게 된다.
//  전역 환경 레코드는 전역 객체의 프로퍼티나 메서드가 되는 `var`, `function`으로 선언된 전역 변수와 함수를 관리하는 "객체 환경 레코드"와,
//  `let`, `const`를 사용해 선언된 변수와 함수들은 관리하는 "선언적 환경 레코드"로 관리한다.
//  즉, `var`, `function` 키워드를 이용한 전역 변수와 함수, 빌트인 전역 함수, 표준 빌트인 객체를 "객체 환경 레코드"에서 관리하며,
//  `let`, `const` 키워드를 이용한 전역 변수와 함수는 "선언적 환경 레코드"에서 관리된다.
//
//    2-1-1. 객체 환경 레코드 생성 (object environment record)
//    👉 환경 레코드를 구성하는 컴포넌트인 "객체 환경 레코드"를 `BindingObject`라고 부른다. (23-6-1. 전역 객체 생성에서 생성된 전역 객체, 즉 `window`)
//    전역 코드 평가 과정에서 `var` 키워드를 통해 선언한 변수와 `function` 키워드를 통해 선언한 함수는 `BindingObject`를 통해 전역 객체의 프로퍼티와 메서드가 된다.
//    이때 등록된 식별자들은 전역 객체의 프로퍼티를 통해 검색하여 반환한다.
//    🔑 이것이 `var` 키워드와 `function` 키워드로 등록된 변수와 메서드들을 식별자 없이 호출하거나 사용할 수 있는 메커니즘이다. (window.alert() → alert())
//    👉 소스코드의 `var`, `function` 키워드를 이용하여 선언된 `xx`와 `outer`는 "객체 환경 레코드"에 등록된다.
//    `xx`는 선언 → 초기화 단계를 거쳐 암묵적으로 `undefined`가 할당되고, `outer`는 `<function object>`(함수 객체)가 할당된다.
//    이것이 호이스팅이 발생하는 원인이며 변수 호이스팅과 함수 호이스팅의 주요 차이점이다.
//    🔑 변수 호이스팅은 선언 전에 호출 시 항상 `undefined`를 반환하지만, 함수는 호이스팅 시점에 이미 함수 객체가 할당되어 있어 선언 전에 호출 시 동작이 가능하다.
//
//    2-1-2. 선언적 환경 레코드 생성 (declarative environment record)
//    👉 "선언적 환경 레코드"가 생성되고 `let`, `const` 키워드를 이용하여 선언된 식별자들은 "선언적 환경 레코드"에 키로 등록되고 관뢰된다.
//    🔑 소스코드에서 선언된 `yy`가 해당되며, 선언 단계(호이스팅)만 거칠 뿐 초기화 단계가 이뤄지지 않아 식별자에 접근할 수 없는 상태로 `TDZ`가 발생하는 메커니즘이다.
//
//  2-2. this 바인딩 (this binding)
//  👉 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 `this`가 바인딩된다.
//  일반적으로 전역 코드의 `this`는 최상위 객체인 전역 객체가 바인딩된다.
//  "객체 환경 레코드"와 "선언적 환경 레코드"에는 `this` 바인딩이 존재하지 않으며, `this` 바인딩은 "전역 환경 레코드"와 "함수 환경 레코드"에만 존재한다.
//
//  2-3. 외부 렉시컬 환경에 대한 참조 결정 (global lexical environment reference)
//  👉 "외부 렉시컬 환경에 대한 참조"는 현재 실행 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경을 가리킨다.
//  즉, 상위 스코프를 의미하며, 이를 통해 단반향 링크드 리스트인 스코프체인을 구현한다.
//  전역 소스코드를 포함하는 소스코드는 존재 하지 않기 때문에 `null`이 할당된다.
// --------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------
// ✅ 23-6-3. 전역 코드 실행
// 👉 전역 코드 평가가 끝나고 전역 코드가 실행되면 `xx`, `yy`에 값이 할당되며, `outer`함수가 호출된다.
// 🔑 `outer`함수가 "전역 환경 레코드"에 등록되어 있지 않다면, "외부 렉시컬 환경에 대한 참조"를 통해 `outer`식별자를 찾는다. 이것이 스코프체인이 발생하는 메커니즘이다.
// 만약 `outer`식별자가 상위 스코프에도 존재하지 않는다면 referenceError를 발생시킨다.
// --------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------
// ✅ 23-6-4. outer 함수 코드 평가
// `outer` 함수가 호출되면 전역 코드의 실행을 일시 중단하고 `outer` 함수 내부로 코드의 제어권이 이동하고 함수코드를 평가하기 시작한다.
//
// 1. 함수 실행 컨텍스트 생성 (function execution context)
// 👉 함수 실행 컨텍스트를 생성하고 호출 스택에 푸시한다. 이때 함수 실행 컨텍스트 스택은 코드의 제어권을 가지는 실행 중인 실행 컨텍스트가 된다.
//
// 2. 함수 렉시컬 환경 생성 (function lexical environment)
// 👉 함수 렉시컬 환경을 생성하고 함수 실행 컨텍스트에 바인딩한다.
// 함수 렉시컬 환경은 "함수 환경 레코드"와 "외부 렉시컬 환경에 대한 참조" 2가지 컴포넌트로 구성된다.
//
//  2-1. 함수 환경 레코드 생성 (function environment record)
//  👉 함수 환경 레코드는 매개변수, arguments 객체, 함수 내부에 선언한 지역 변수와 중첩 함수를 등록하고 관리한다.
//  🔑 `aa` 매개변수는 `undefined`, arguments 객체는 { 0: 20, length: 1, callee: outer }, `xx`는 `undefined`, `yy`는 초기화 전(uninitialized), `inner`는 <function object>`의 값을 가진다.
//
//  2-2. this 바인딩 (this binding)
//  👉 함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 `this`가 바인딩된다. [[ThisValue]] 내부 슬롯의 바인딩 값은 함수 호출 방식에 따라 결정된다.
//  🔑 `outer` 함수는 일반 함수로 호출되어 [[ThisValue]] 내부 슬롯은 전역 객체가 바인딩된다.
//
//  2-3. 외부 렉시컬 환경에 대한 참조 결정 (outer lexical environment reference)
//  👉 외부 렉시컬 환경에 대한 참조에 `outer` 함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다.
//  `outer` 함수는 전역 함수다. 따라서 `outer` 함수 정의는 전역 코드 평가 시점에 평가된다. 이 시점의 실행 중인 실행 컨텍스트는 전역 실행 컨텍스트다.
//  즉, 외부 렉시컬 환경에 대한 참조에는 전역 렉시컬 환경이 참조된다.
//  🔑 이것이 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정하는 렉시컬 스코프이다.
// --------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------
// ✅ 23-6-4. outer 함수 코드 실행
// 👉 함수 코드 평가가 끝나고 `outer` 함수의 런타임이 시작되면 매개변수 `aa`에 값이 할당되고, 변수 할당문이 실행되어 지역 변수 `xx`, `yy`에 값이 할당된 뒤 `inner` 함수가 호출된다.
// 🔑 이때 식별자의 결정을 위해 실행 중인 함수 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색한다.
// 만약 현재 실행중인 함수 실행 컨텍스트의 함수 렉시컬 환경에서 식별자를 찾을 수 없다면 외부 렉시컬 환경 참조가 가리키는 상위 스코프의 렉시컬 환경에서 식별자를 검색한다.
// --------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------
// ✅ 23-6-6. inner 함수 코드 평가
// `inner` 함수가 호출되면 `outer` 함수 코드 실행을 일시 중단하고 `inner` 함수 내부로 코드의 제어권이 이동하고 함수코드를 평가하기 시작한다.
//
// 1. 함수 실행 컨텍스트 생성 (function execution context)
// 👉 함수 실행 컨텍스트를 생성하고 호출 스택에 푸시한다. 이때 함수 실행 컨텍스트 스택은 코드의 제어권을 가지는 실행 중인 실행 컨텍스트가 된다.
//
// 2. 함수 렉시컬 환경 생성 (function lexical environment)
// 👉 함수 렉시컬 환경을 생성하고 함수 실행 컨텍스트에 바인딩한다.
// 함수 렉시컬 환경은 "함수 환경 레코드"와 "외부 렉시컬 환경에 대한 참조" 2가지 컴포넌트로 구성된다.
//
//  2-1. 함수 환경 레코드 생성 (function environment record)
//  👉 함수 환경 레코드는 매개변수, arguments 객체, 함수 내부에 선언한 지역 변수와 중첩 함수를 등록하고 관리한다.
//  🔑 `bb` 매개변수는 `undefined`, arguments 객체는 { 0: 10, length: 1, callee: inner }, `zz`는 초기화 전(uninitialized)의 값을 가진다.
//
//  2-2. this 바인딩 (this binding)
//  👉 함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 `this`가 바인딩된다. [[ThisValue]] 내부 슬롯의 바인딩 값은 함수 호출 방식에 따라 결정된다.
//  🔑 `inner` 함수는 일반 함수로 호출되어 [[ThisValue]] 내부 슬롯은 전역 객체가 바인딩된다.
//
//  2-3. 외부 렉시컬 환경에 대한 참조 결정 (outer lexical environment reference)
//  👉 외부 렉시컬 환경에 대한 참조에 `inner` 함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다.
//  `inner` 함수는 중첩 함수다. 따라서 `inner` 함수 정의는 `outer` 함수 코드 평가 시점에 평가된다. 이 시점의 실행 중인 실행 컨텍스트는 함수 실행 컨텍스트다.
//  즉, 외부 렉시컬 환경에 대한 참조에는 `outer` 함수의 렉시컬 환경이 참조된다.
//  🔑 이것이 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정하는 렉시컬 스코프이다.
// --------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------
// ✅ 23-6-7. inner 함수 코드 실행
// 👉 함수 코드 평가가 끝나고 `inner` 함수의 런타임이 시작되면 매개변수 `bb`에 값이 할당되고, 변수 할당문이 실행되어 지역 변수 `zz`에 값이 할당되고 `console.log`가 실행된다.
// 1. console 식별자 검색
//  - `console` 식별자를 스코프 체인에서 검색한다.
//  - 식별자가 검색해서 나오지 않는다면 외부 렉시컬 환경을 참조한다.
//  - `console` 식별자는 최상위 스코프의 객체 환경 레코드에 존재한다.
//
// 2. log 메서드 검색
//  - `console` 객체에서 `log` 메서드를 검색한다.
//  - `log` 메서드는 상속된 프로퍼티가 아니라 `console` 객체가 직접 소유하는 프로퍼티다.
console.hasOwnProperty("log"); // true
//
// 3. 표현식 `aa + bb + xx + yy + zz` 의 평가
//  - `log` 메서드에 전달할 인수, 즉 표현식 `aa + bb + xx + yy + zz`를 평가하기 위해 각 식별자들을 검색한다.
//  - `aa` 식별자는 `outer` 함수의 렉시컬 환경에서
//  - `bb` 식별자는 `inner` 함수의 렉시컬 환경에서
//  - `xx`, `yy` 식별자는 `outer` 함수의 렉시컬 환경에서
//  - `zz` 식별자는 `inner` 함수의 렉시컬 환경에서 검색된다.
//
// 4. console.log 메서드 호출
//  - 표현식 `aa + bb + xx + yy + zz`가 평가되어 생성한 값(42)를 console.log 메서드에 전달하여 호출한다.
// --------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------
// ✅ 23-6-8. inner 함수 코드 실행 종료
// 👉 `inner` 함수의 `log` 메서드를 끝으로 더는 실행할 코드가 없어 `inner` 함수는 실행이 종료된다.
// 이때 호출 스택에서 `inner` 함수의 실행 컨텍스트가 팝 되어 제거되고 `outer` 함수 실행 컨텍스트는 실행 중인 실행 컨텍스트가 된다.
// 🚨 호출 스택에서 `inner` 함수의 실행 컨텍스트가 제거되었다고 해서 `inner` 함수의 렉시컬 환경까지 즉시 소멸하는 것은 아니다!
// 🔑 렉시컬 환경은 호출 스택에 실행 컨텍스트가 푸쉬될 때 생성되는 것은 맞지만 실행 컨텍스트에 참조되는 독립적인 객체다.
// 즉, 객체를 포함한 모든 값은 누군가에 의해 참조되지 않을 때 가비지 컬렉터에 의해 소멸한다.
// `inner` 실행 컨텍스트가 호출 스택에서 제거되었더라도 `inner` 함수의 렉시컬 환경을 누군가 참조한다면 소멸하지 않고 유지된다.
// --------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------
// ✅ 23-6-9. outer 함수 코드 실행 종료
// 👉 `outer` 함수에서 더는 실행할 코드가 없어 `outer` 함수의 실행이 종료된다.
// 이때 호출 스택에서 `outer` 함수의 실행 컨텍스트가 팝 되어 제거되고 전역 실행 컨텍스트는 실행 중인 실행 컨텍스트가 된다.
// --------------------------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------------------------
// ✅ 23-6-10. 전역 코드 실행 종료
// 👉 전역 코드에서 더는 실행할 코드가 없어 전역 코드의 실행이 종료된다.
// 이때 전역 실행 컨텍스트도 호출 스택에서 팝 되어 제거되고 호출 스택에는 아무것도 남아있지 않게 된다.
// --------------------------------------------------------------------------------------------------------------

/**
 * 23-7. 실행 컨텍스트와 블록 레벨 스코프
 *
 * `if`, `for`, `while`, `try/catch` 등의 모든 코드 블럭 내부에서 `let`, `const`를 통해 선언된 식별자들은
 * 블록 렉시컬 환경(block lexical environment)에 의해 관리된다.
 * 블록 렉시컬 환경은 실행 컨텍스트 생성 시 생성되는 렉시컬 환경과는 독립적인 환경이며, 서로 다른 범위를 관리한다.
 *
 */

// 👉 소스코드 예문
{
  let x = 1;

  if (true) {
    let x = 10;
    x; // 10
  }

  x; // 1
}

// if 문의 코드 블록내에서 `let` 키워드로 변수가 선언되었다.
// 따라서 if 문의 코드 블록이 실행되려면 if 문의 코드 블록을 위한 독립적인 블록 레벨 스코프를 생성해야한다.
// 이때 생성되는 렉시컬 환경은 "블록 렉시컬 환경"으로 렉시컬 환경과 동일하게 환경 레코드와 외부 렉시컬 환경 참조로 구성되어 있다.
// 환경 레코드의 선언적 환경 레코드에서 `x`를 등록하고 `10`을 할당하게 된다.
// 외부 렉시컬 환경 참조는 상위 스코프를 참조하게 된다.
// 이는 if 문뿐 아니라 블록 레벨 스코프를 생성하는 모든 블록문에 적용된다.
// 👉 즉, 블록 환경 레코드는 모든 블록문에 적용되며, 실행 컨텍스트의 렉시컬 환경과는 독립적인 환경이다.
